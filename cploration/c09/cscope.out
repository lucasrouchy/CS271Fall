cscope 15 $HOME/Documents/CS271Fall/nand2tetris/projects/cploration/c09               0000008299
	@error.c

1 
	~"îr‹.h
"

2 
	~<°dio.h
>

3 
	~<°dlib.h
>

6 c⁄° *
	gîr‹_mesßges
[] =

8 [
EXIT_INCORRECT_ARGUMENTS
] = "Usage: %s [filename]",

9 [
EXIT_CANNOT_OPEN_FILE
] = "Cannot open file: %s [filename]",

10 [
EXIT_TOO_MANY_INSTRUCTIONS
] = "File contains moreÅhanÅhe maximum of %u instructions.",

11 [
EXIT_INVALID_LABEL
] = "Line %u: %s: invalidÜabelÇame.",

12 [
EXIT_SYMBOL_ALREADY_EXISTS
] = "Line %u: %s : Symbol isálready defined",

13 [
EXIT_INVALID_A_INSTR
] = "Line %u: %s : Invalid A-instruction operand",

16 
	$exô_¥ogøm
(
exôcode
 
code
, ...)

18 
va_li°
 
¨gumíts
;

19 
	`va_°¨t
(
¨gumíts
, 
code
);

21 
	`¥ötf
("ERROR: ");

22 
	`vÂrötf
(
°dout
, 
îr‹_mesßges
[
code
], 
¨gumíts
);

23 
	`¥ötf
("\n");

25 
	`va_íd
(
¨gumíts
);

26 
	`exô
(
code
);

27 
	}
}

	@error.h

1 #i‚de‡
__ERROR_H__


2 
	#__ERROR_H__


	)

3 
	~<°d¨g.h
>

13 
	eexôcode
 {

14 
	mEXIT_INCORRECT_ARGUMENTS
 = 1,

15 
	mEXIT_CANNOT_OPEN_FILE
 = 2,

16 
	mEXIT_TOO_MANY_INSTRUCTIONS
 = 3,

17 
	mEXIT_INVALID_LABEL
 = 4,

18 
	mEXIT_SYMBOL_ALREADY_EXISTS
 = 5,

19 
	mEXIT_INVALID_A_INSTR
 = 6,

22 
exô_¥ogøm
(
exôcode
 
code
, ...);

	@hack.h

1 #i‚de‡
__HACK_H__


2 
	#__HACK_H__


	)

3 
	#NUM_PREDEFINED_SYMBOLS
 23

	)

6 
	esymbﬁ_id
 {

7 
	mSYM_R0
 = 0,

8 
	mSYM_R1
 = 1,

9 
	mSYM_R2
 = 2,

10 
	mSYM_R3
 = 3,

11 
	mSYM_R4
 = 4,

12 
	mSYM_R5
 = 5,

13 
	mSYM_R6
 = 6,

14 
	mSYM_R7
 = 7,

15 
	mSYM_R8
 = 8,

16 
	mSYM_R9
 = 9,

17 
	mSYM_R10
 = 10,

18 
	mSYM_R11
 = 11,

19 
	mSYM_R12
 = 12,

20 
	mSYM_R13
 = 13,

21 
	mSYM_R14
 = 14,

22 
	mSYM_R15
 = 15,

23 
	mSYM_SCREEN
 = 16384,

24 
	mSYM_KBD
 = 24576,

25 
	mSYM_SP
 = 0,

26 
	mSYM_LCL
 = 1,

27 
	mSYM_ARG
 = 2,

28 
	mSYM_THIS
 = 3,

29 
	mSYM_THAT
 = 4,

33 
	s¥edeföed_symbﬁ
 {

34 
	m«me
[10];

35 
öt16_t
 
	maddªss
;

36 } 
	t¥edeföed_symbﬁ
;

39 c⁄° 
¥edeföed_symbﬁ
 
	g¥edeföed_symbﬁs
[
NUM_PREDEFINED_SYMBOLS
] = {

40 {"R0", 
SYM_R0
},

41 {"R1", 
SYM_R1
},

42 {"R2", 
SYM_R2
},

43 {"R3", 
SYM_R3
},

44 {"R4", 
SYM_R4
},

45 {"R5", 
SYM_R5
},

46 {"R6", 
SYM_R6
},

47 {"R7", 
SYM_R7
},

48 {"R8", 
SYM_R8
},

49 {"R9", 
SYM_R9
},

50 {"R10", 
SYM_R10
},

51 {"R11", 
SYM_R11
},

52 {"R12", 
SYM_R12
},

53 {"R13", 
SYM_R13
},

54 {"R14", 
SYM_R14
},

55 {"R15", 
SYM_R15
},

56 {"SCREEN", 
SYM_SCREEN
},

57 {"KBD", 
SYM_KBD
},

58 {"SP", 
SYM_SP
},

59 {"LCL", 
SYM_LCL
},

60 {"ARG", 
SYM_ARG
},

61 {"THIS", 
SYM_THIS
},

62 {"THAT", 
SYM_THAT
},

	@main.c

1 
	~"∑r£r.h
"

2 
	~"îr‹.h
"

4 
	$maö
(
¨gc
, * 
¨gv
[]) {

6 i‡(
¨gc
 != 2) {

8 
	`exô_¥ogøm
(
EXIT_INCORRECT_ARGUMENTS
, 
¨gv
[0]);

11 
FILE
* 
fö
 = 
	`f›í
(
¨gv
[1], "r");

13 i‡(
fö
 =
NULL
) {

14 
	`exô_¥ogøm
(
EXIT_CANNOT_OPEN_FILE
, 
¨gv
[1]);

19 
	`∑r£
(
fö
);

21 
	`f˛o£
(
fö
);

24 
	}
}

	@parser.c

1 
	~"∑r£r.h
"

2 
	~"îr‹.h
"

3 
	~"symèbÀ.h
"

6 
	$∑r£
(
FILE
* 
fûe
) {

7 
löe
[
MAX_LINE_LENGTH
] = {0};

8 
löe_num
 = 0;

9 
ö°r_num
 = 0;

10 
a_ö°ru˘i⁄
 
ö°r
;

12 
	`add_¥edeföed_symbﬁs
();

13 
	`symèbÀ_di•œy_èbÀ
();

15 
	`fgës
(
löe
, ÷öe), 
fûe
)) {

16 
löe_num
++;

17 if(
ö°r_num
 > 
MAX_INSTRUCTIONS
){

18 
	`exô_¥ogøm
(
EXIT_TOO_MANY_INSTRUCTIONS
, 
MAX_INSTRUCTIONS
 + 1);

20 
	`°rù
(
löe
);

22 if(!*
löe
)

24 
ö°_ty≥
 = {0};

25 i‡(
	`is_Aty≥
(
löe
)) {

26 i‡(!
	`∑r£_A_ö°ru˘i⁄
(
löe
, &
ö°r
.
A‹C
.
Aty≥
)){

27 
	`exô_¥ogøm
(
EXIT_INVALID_A_INSTR
, 
löe_num
, 
löe
);

29 
ö°r
.
ôy≥
 = 
INST_A
;

30 
ö°_ty≥
 = 'A';

32 i‡(
	`is_œbñ
(
löe
)){

33 
ö°_ty≥
= 'L';

34 
√w_œbñ
[(
löe
)] = {0};

35 
	`exåa˘_œbñ
(
löe
,
√w_œbñ
);

36 if(
	`ißÕha
(
löe
[0])){

37 
	`exô_¥ogøm
(
EXIT_INVALID_LABEL
, 
löe_num
, 
löe
);

39 if(
	`symèbÀ_föd
(
√w_œbñ
Ë=
NULL
) {

40 
	`exô_¥ogøm
(
EXIT_SYMBOL_ALREADY_EXISTS
, 
löe_num
, 
löe
);

42 
	`symèbÀ_ö£π
(
√w_œbñ
, 
ö°r_num
);

44 
	`¥ötf
("%¯ %s\n",
ö°_ty≥
, 
√w_œbñ
 );

47 if(
	`is_Cty≥
(
löe
)){

48 
ö°_ty≥
 = 'C';

50 
	`¥ötf
("%¯ %s\n",
ö°_ty≥
 , 
löe
);

51 
ö°r_num
++;

54 
	}
}

57 * 
	$°rù
(* 
s
) {

58 
s_√w
[
MAX_LINE_LENGTH
 + 1] = {0};

59 
i
 = 0;

61 * 
s2
 = 
s
; *s2; s2++) {

63 if(*
s2
 == '/' && *(s2+1) == '/') {

67 if(!
	`is•a˚
(*
s2
)) {

68 
s_√w
[
i
++] = *
s2
;

71 
s_√w
[
i
]= '\0';

72 
	`°r˝y
(
s
, 
s_√w
);

74  
s
;

75 
	}
}

76 
boﬁ
 
	$is_Aty≥
(c⁄° * 
löe
) {

77 i‡(*
löe
== '@' ){

78  
åue
;

81  
Ál£
;

83 
	}
}

84 
boﬁ
 
	$is_œbñ
(c⁄° * 
löe
){

85 i‡(
löe
[0]='(' &&Üöe[
	`°æí
(line)-1]==')')

86  
åue
;

88  
Ál£
;

89 
	}
}

90 
boﬁ
 
	$is_Cty≥
(c⁄° * 
löe
){

91 i‡(!
	`is_Aty≥
(
löe
Ë&& !
	`is_œbñ
(line))

92  
åue
;

94  
Ál£
;

95 
	}
}

96 * 
	$exåa˘_œbñ
(c⁄° * 
löe
, * 
œbñ
){

97 
	`°∫˝y
(
œbñ
, 
löe
+1, 
	`°æí
(line)-2);

98  
œbñ
;

99 
	}
}

102 
	$add_¥edeföed_symbﬁs
(){

103 
i
 = 0; i < 
NUM_PREDEFINED_SYMBOLS
; i++) {

104 
¥edeföed_symbﬁ
 
myv¨
 = 
¥edeföed_symbﬁs
[
i
];

105 
	`symèbÀ_ö£π
(
myv¨
.
«me
, myv¨.
addªss
);

107 
	}
}

110 
boﬁ
 
	$∑r£_A_ö°ru˘i⁄
(c⁄° *
löe
, 
a_ö°ru˘i⁄
 *
ö°r
){

111 * 
s
 = 
	`mÆloc
(
	`°æí
(
löe
));

112 
	`°r˝y
(
s
, 
löe
+1);

113 * 
s_íd
 = 
NULL
;

114 
ªsu…
 = 
	`°πﬁ
(
s
, &
s_íd
, 10);

115 i‡(
	`°rcmp
(
s
, 
s_íd
) == 0){

116 
ö°r
->
hack_addr
.
œbñ
 = 
	`mÆloc
(
	`°æí
(
löe
));

117 
	`°r˝y
(
ö°r
->
hack_addr
.
œbñ
, 
s
);

118 
ö°r
->
is_addr
 = 
Ál£
;

120 i‡(*
s_íd
 != 0) {

121  
Ál£
;

124 
ö°r
->
hack_addr
.
addªss
 = 
ªsu…
;

125 
ö°r
->
is_addr
 = 
åue
;

128  
åue
;

129 
	}
}

	@parser.h

1 #i‚de‡
__PARSER_H__


2 
	#__PARSER_H__


	)

4 
	~<°dio.h
>

5 
	~<°rög.h
>

6 
	~<°dlib.h
>

7 
	~<˘y≥.h
>

8 
	~<°dboﬁ.h
>

9 
	~<°döt.h
>

10 
	~"hack.h
"

13 
	#MAX_LINE_LENGTH
 200

	)

14 
	#MAX_LABEL_LENGTH
 
MAX_LINE_LENGTH
 -2

	)

15 
	#MAX_HACK_ADDRESS
 
INT16_MAX


	)

16 
	#MAX_INSTRUCTIONS
 
MAX_HACK_ADDRESS


	)

18 
add_¥edeföed_symbﬁs
();

19 * 
°rù
(* 
s
);

20 
∑r£
(
FILE
* 
fûe
);

21 
boﬁ
 
is_Aty≥
(const *);

22 
boﬁ
 
is_œbñ
(const *);

23 
boﬁ
 
is_Cty≥
(const *);

24 
öt16_t
 
	thack_addr
;

25 
öt16_t
 
	t›code
;

26 *
exåa˘_œbñ
(c⁄° *
löe
, * 
œbñ
);

28 
	eö°_ty≥
 {

29 
	mövÆid
 = -1,

30 
	mAty≥
,

31 
	mCty≥
,

35 
	sc_ö°ru˘i⁄
 {

36 
›code
 
	ma
: 1;

37 
›code
 
	mcomp
: 6;

38 
›code
 
	mde°
:3;

39 
›code
 
	mjump
: 3;

40 } 
	tc_ö°ru˘i⁄
;

42 
	sa_ö°ru˘i⁄
 {

43 
	uhack_addr
 {

44 
hack_addr
 
	maddªss
;

45 * 
	mœbñ
;

46 } 
	mhack_addr
;

47 
boﬁ
 
	mis_addr
;

48 } 
	ta_ö°ru˘i⁄
;

50 
	sö°ru˘i⁄
 {

51 
	uA‹C
 {

52 
ö°_ty≥
 
	mAty≥
;

53 
ö°_ty≥
 
	mCty≥
;

54 } 
	mA‹C
;

55 } 
	tö°ru˘i⁄
;

57 
boﬁ
 
∑r£_A_ö°ru˘i⁄
(c⁄° *
löe
, 
a_ö°ru˘i⁄
 *
ö°r
);

	@symtable.c

1 
	~"symèbÀ.h
"

4 
	$hash
(* 
°r
) {

5 
hash
 = 5381;

6 
c
;

8 (
c
 = *
°r
++))

9 
hash
 = ((hash << 5Ë+ hashË+ 
c
;

11  
hash
 % 
SYMBOL_TABLE_SIZE
;

12 
	}
}

14 
	$symèbÀ_ö£π
(* 
key
, 
hack_addr
 
addr
) {

16 
Symbﬁ
* 
ôem
 = (Symbﬁ*Ë
	`mÆloc
((Symbol));

17 
ôem
->
addªss
 = 
addr
;

18 
ôem
->
«me
 = (*)
	`mÆloc
(
	`°æí
(
key
) + 1);

19 
	`°r˝y
(
ôem
->
«me
, 
key
);

23 
hashIndex
 = 
	`hash
(
key
);

26 
hashAºay
[
hashIndex
] !
NULL
 && hashAºay[hashIndex]->
«me
 != NULL) {

28 ++
hashIndex
;

29 
hashIndex
 %
SYMBOL_TABLE_SIZE
;

32 
hashAºay
[
hashIndex
] = 
ôem
;

33 
	}
}

35 
Symbﬁ
* 
	$symèbÀ_föd
(* 
key
) {

36 
hashIndex
 = 
	`hash
(
key
);

38 
hashAºay
[
hashIndex
] !
NULL
) {

39 if(
hashAºay
[
hashIndex
]->
«me
 =
key
)

40  
hashAºay
[
hashIndex
];

42 ++
hashIndex
;

44 
hashIndex
 %
SYMBOL_TABLE_SIZE
;

47  
NULL
;

48 
	}
}

51 
	$symèbÀ_di•œy_èbÀ
() {

52 
i
 = 0; i < 
SYMBOL_TABLE_SIZE
; i++) {

53 if(
hashAºay
[
i
] !
NULL
)

54 
	`¥ötf
(" (%s,%d)", 
hashAºay
[
i
]->
«me
, hashAºay[i]->
addªss
);

56 
	`¥ötf
(" ~~ ");

58 
	`¥ötf
("\n");

59 
	}
}

	@symtable.h

1 #i‚de‡
__SYMTABLE_H__


2 
	#__SYMTABLE_H__


	)

3 
	~<°dio.h
>

4 
	~<°rög.h
>

5 
	~<°dlib.h
>

6 
	~<˘y≥.h
>

7 
	~<°dboﬁ.h
>

8 
	~<°döt.h
>

15 
	#SYMBOL_TABLE_SIZE
 100

	)

17 
öt16_t
 
	thack_addr
;

20 
hack_addr
 
	maddªss
;

21 * 
	m«me
;

22 } 
	tSymbﬁ
;

24 
Symbﬁ
* 
	ghashAºay
[
SYMBOL_TABLE_SIZE
];

25 
hash
(* 
°r
);

26 
Symbﬁ
* 
symèbÀ_föd
(* 
key
);

27 
symèbÀ_ö£π
(* 
key
, 
hack_addr
 
addr
);

28 
symèbÀ_di•œy_èbÀ
();

	@
1
.
0
8
70
error.c
error.h
hack.h
main.c
parser.c
parser.h
symtable.c
symtable.h
